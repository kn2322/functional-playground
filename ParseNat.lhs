Parser example for natural numbers, in response to a post on Reddit. This file can be run, and I suggest testing out `parseNat`, `parseNat'`, and `parseNat''` yourself.

We model a parser as a computation which takes a string, consumes part of it, and returns a result. This is something of type `String -> (a, String)`. To give some powerful flexibility, we return a list of (result, remaining string), to allow for non-determinism and failure. This gives us the parser type

\begin{code}
data Parser a = Parser (String -> [(a, String)])

-- an unwrapper to run the parse function
parse :: Parser a -> String -> [(a, String)]
parse (Parser p) s = p s
\end{code}

For example, we can parse some basic parts of `Nat` like so:

\begin{code}
data Nat = Succ Nat | Zero deriving Show

parseZero :: Parser Nat
parseZero = Parser p
    where
        p "" = [] -- fail
        p (x:xs) = case x of
            '0' -> [(Zero, xs)] -- consume x
            _ -> [] -- fail

parseSuccFirst :: Parser ()
-- no result, if we get anything back, we know we have a Succ
parseSuccFirst = Parser p
    where
        p s
            | length s < 4 = []
            | take 4 s == "succ" = [((), drop 4 s)]

parseBracket :: Parser ()
-- no result, we consume the brackets from the input
parseBracket = Parser p
    where
        p s
            | length s < 2 = []
            | head s == '(' && last s == ')' = [((), init (tail s))]
\end{code}

We can even put together a parser for `Nat`, supposing we are strict about white space.

\begin{code}
parseNat :: Parser Nat
parseNat = Parser p
    where
        p s = case parse parseZero s of
            [(Zero, "")] -> [(Zero, "")]
            [] -> case parse parseSuccFirst s of
                [(res, s')] -> case parse parseBracket s' of
                    [((), s'')] -> case parse parseNat s'' of
                        [(n, "")] -> [(Succ n, "")]
                        [] -> []
                    [] -> [] -- fail
                [] -> [] -- fail
\end{code}

Some examples to see that it works:

\begin{spec}
*Main> parse parseNat "0"
[(Zero,"")]
*Main> parse parseNat "succ(0)"
[(Succ Zero,"")]
*Main> parse parseNat "succ"
[]
*Main> parse parseNat "succ0"
[]
*Main> parse parseNat "succ(succ(0))"
[(Succ (Succ Zero),"")]
*Main> parse parseNat "succ(succ(0)"
*** Exception: ParseNat.lhs:(36,9)-(38,68): Non-exhaustive patterns in function p

*Main> parse parseNat "succ(succ(succ(0)))"
[(Succ (Succ (Succ Zero)),"")]
\end{spec}

The language that we are parsing is generated by an unambiguous grammar, so all the parsers so far do not use non-determinism. They either return a singleton list or fail.

Now, the parser datatype so far works, and it is fairly clear why it works. But I have been keeping a sort of secret so far: this is not at all how I would write a parser using the datatype Parser. The reason is that we can do much better, by following the functional programming urge to capture patterns. `parseNat` would no longer need four nested case expressions, and we would say goodbye to guards against length in `parseSuccFirst` and `parseBracket`.

Our construction starts with the most basic parts of our existing parser. First, we write a parser for parsing a single character.

\begin{code}
parseChar :: Char -> Parser Char
parseChar c = Parser p
    where
        p s = case s of
            (x:xs) -> if x == c then [(x, xs)] else []
            [] -> []
\end{code}

Now that we have a character, let us recover `parseZero`. We do this by a mechanism to transform the result of a parse, without touching the remaining input string. It turns out the `Functor` typeclass is exactly what we are looking for.

\begin{code}
instance Functor Parser where
    -- fmap :: (a -> b) -> Parser a -> Parser b
    -- the type of fmap tells us it lets us transform the result of a parse
    fmap f parser = Parser p
        where
            p s = [(f x, s') | (x, s') <- parse parser s]

-- we overwrite '0' with Zero using the constant Zero function
-- const Zero :: a -> Nat
parseZero' :: Parser Nat
parseZero' = fmap (const Zero) (parseChar '0')
\end{code}

To parse `succ`, we build a general string parser `parseString` by sequencing applications of `parseChar`.

\begin{code}
parseString :: String -> Parser String
parseString "" = Parser p
    where
        p s = [("", s)]

parseString (x:xs) = Parser p
    where
        p s = [(x:xs, s'') |
            (_, s') <- parse (parseChar x) s, -- parse first character
            (_, s'') <- parse (parseString xs) s'] -- parse the rest
            -- if either of the parses fail, the resulting (x:xs, s'') will not be included in p s
            -- in particular, if the input string is too short, parseChar would fail at some point, which would make p s empty

parseSuccFirst' :: Parser ()
parseSuccFirst' = fmap (const ()) (parseString "succ")
\end{code}

Now we need to parse a pair of brackets. Let us do the right bracket by a way to parse a string from the end. This would be a higher order function taking parsers to parsers, a kind of parser combinator or transformer.

\begin{code}
parseBackwards :: Parser a -> Parser a
parseBackwards parser = Parser p
    where
        p s = [(a, reverse s') | (a, s') <- parse parser (reverse s)]

parseBracket' :: Parser ()
parseBracket' = Parser p
    where
        p s = [((), s'') |
            (_, s') <- parse (parseChar '(') s,
            let pb = parseBackwards (parseChar ')'),
            (_, s'') <- parse pb s']
            -- ignore parse results by _
\end{code}

In `parseNat`, we select between the alternatives of parsing `Zero` or parsing `Succ (...)`. We can write a combinator to parse `Zero`, and if it fails, parse `Succ (...)`.

\begin{code}
orElse :: Parser a -> Parser a -> Parser a
orElse f g = Parser p
    where
        p s = case parse f s of
            [] -> parse g s
            res -> res
\end{code}

Finally, we put everything together:

\begin{code}
parseNat' :: Parser Nat
parseNat' = total (orElse parseZero' g)
    where
        g = Parser q
        q s = [(Succ n, s''') |
            (_, s') <- parse parseSuccFirst' s,
            (_, s'') <- parse parseBracket' s',
            (n, s''') <- parse parseNat' s'']

-- total makes sure we consume the whole string
total :: Parser a -> Parser a
total parser = Parser p
    where
        p s = [(n, s') | (n, s') <- parse parser s, null s']
\end{code}

At this point, we have a parser which is conceptually higher level than our first idea, and we can take it one step further. We have been using quite a lot of list comprehension, mostly so we can sequence parses in some way. The applicative functor typeclass `Applicative` lets us capture this pattern, with the bonus of a few laws and a vast pool of combinators available from `Control.Applicative`.

\begin{code}
instance Applicative Parser where
    -- pure :: a -> Parser a
    -- returns a value without consuming any input
    pure x = Parser p
        where p s = [(x, s)]
    -- (<*>) :: Parser (a -> b) -> Parser a -> Parser b
    -- we parse a function first, then parse an input to that function
    -- then we apply the parsed function to the parsed input
    fa <*> xa = Parser p
        where
            p s = [(f x, s'') |
                (f, s') <- parse fa s,
                (x, s'') <- parse xa s']
    -- (*>) :: Parser a -> Parser b -> Parser b
    -- pure sequencing, where we ignore the result of the first parse
    xa *> ya = Parser p
        where
            p s = [(y, s'') |
                (x, s') <- parse xa s,
                (y, s'') <- parse ya s']

    -- reverse sequencing, where we ignore the result of the second parse
    xa <* ya = Parser p
        where
            p s = [(x, s'') |
                (x, s') <- parse xa s,
                (y, s'') <- parse ya s']

    -- a synonym for fmap, a 'pure' application
    --f <$> xa = fmap f xa
\end{code}

We will mainly be using `*>` and `<*` rather than `<*>`, but it turns out that `*>` and `<*` can in general be defined in terms of `<*>`, by

< xa *> ya = (\x y -> y) <$> xa <*> ya
< xa <* ya = (\x y -> x) <$> xa <*> ya

With all that out of the way, we have our final version of the parser,

\begin{code}
parseString' "" = pure ""
parseString' (x:xs) = (:) <$> parseChar x <*> parseString' xs

parseNat'' = total (orElse parseZero' (Succ <$> parseS))
    where
        parseS =
            parseString' "succ" *> parseBracket' *> parseNat''
\end{code}

This is abstract to the point that we almost never unpack the `Parser` constructor, instead only thinking in terms of combinators and sequencing. The only places where we need to resort to our initial concrete style is in the basic building blocks `parseChar`, `parseBackwards`, `total`, and `orElse`.

Notice how the structure of the parser mirrors the structure of the datatype `Nat`. Parsing algebraic datatypes in general can be done this way, by writing a parser mirroring its structure. I believe this is called a 'recursive descent parser'.

Hopefully this serves as a hands-on introduction to parsing, happy haskelling :)
